<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ilife]]></title>
  <link href="www.ilife.co/atom.xml" rel="self"/>
  <link href="www.ilife.co/"/>
  <updated>2017-04-23T17:22:37+08:00</updated>
  <id>www.ilife.co/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Day 2]]></title>
    <link href="www.ilife.co/14931140045313.html"/>
    <updated>2017-04-25T17:53:24+08:00</updated>
    <id>www.ilife.co/14931140045313.html</id>
    <content type="html"><![CDATA[
<p>Try to implement Decimal to Hex.</p>

<pre><code class="language-java">
public static void main(String[] args) {
   int n = 4123;

   int power = 1;
   while (power &lt;= (n / 16)) {
       power *= 16;
   }

   while (power &gt; 0) {
       if (n &gt;= power) {
           hexOutput(n, power);
           n = n - power;
       }else {
           hexOutput(n, power);
       }
       power = power / 16;
   }
}

private static void hexOutput(int n, int power) {
   switch (n / power) {
       case 15:
           System.out.println(&quot;F&quot;);
           break;
       case 14:
           System.out.println(&quot;E&quot;);
           break;
       case 13:
           System.out.println(&quot;D&quot;);
           break;
       case 12:
           System.out.println(&quot;C&quot;);
           break;
       case 11:
           System.out.println(&quot;B&quot;);
           break;
       case 10:
           System.out.println(&quot;A&quot;);
           break;
       default:
           System.out.println(n / power);
   }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Day 1]]></title>
    <link href="www.ilife.co/14929392382338.html"/>
    <updated>2017-04-23T17:20:38+08:00</updated>
    <id>www.ilife.co/14929392382338.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">RxJava</h2>

<blockquote>
<p>The Observer pattern done right. ReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming.      â€” ractivex.io</p>
</blockquote>

<p>Upon  this, it&#39;s obvious that we should first familiar the Observer pattern, the Iterator pattern and the functional programming. I think I&#39;ll cover these three part later. </p>

<p>The Java version of this concept is called RxJava, which hosted on Github <a href="https://github.com/ReactiveX/RxJava">RxJava</a></p>

<h2 id="toc_1">Main Concept</h2>

<ul>
<li><strong>Observables</strong> Representing sources of data. </li>
<li><strong>Subscribers (Observers)</strong> Listening to the Observables. </li>
<li>a set of methods for modifying and composing the data</li>
</ul>

<p>Some advantages of RxJava:<br/>
* You can chain async operations, e.g. if a API call depends on the call of another API<br/>
* A defined way to handle errors<br/>
* It reduces the need fro state variables, which can be the source of errors == Creating sources, subscribing to them and disposing them</p>

<h2 id="toc_2">Creating sources to observe</h2>

<p>Observables are the sources for the data. Usually they start providing data once a subscriber starts listening. They can produce an empty, a single or multiple items. They can terminate with an error or success. Sources may never terminate, e.g., a observable for a button click can potentially produce an infinite stream of events. </p>

<p><em>Table 1. Table Observable types</em></p>

<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>Flowable<T></td>
<td>Emits 0 or n items and terminates with complete or an error. Supports backpressure, which allows to control how fast a source emits items.</td>
</tr>
<tr>
<td>Observable<T></td>
<td>Emits 0 or n items and terminates with complete or an error.</td>
</tr>
<tr>
<td>Single<T></td>
<td>Emits either a single item or an error. The reactive version of a <code>method call</code>. you subscribe to a Single and you get either a return value or an error.</td>
</tr>
<tr>
<td>Maybe<T></td>
<td>Succeeds with an item, or no item, or errors. The reactive version of an <code>Optional</code>.</td>
</tr>
<tr>
<td>Completeable</td>
<td>Either completes or returns an error. It never return items. The reactive version of a <code>Runnable</code>.</td>
</tr>
</tbody>
</table>

<p>An example for the usage of <code>backpressure</code> is when you process <code>touch events</code>. You cannot control the user who is doing these touch events, but you can tell the source to emit the events on a slower rate in case you cannot processes them at the rate the user produces them. This has been designed for the support fro reactive streams. Only <code>Flowable</code> supports backpressure.</p>

<pre><code class="language-java">Observable&lt;Interger&gt; observable = Observable.create(new ObserverableOnSubscribe&lt;Integer&gt;(){
    @Override
    public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; observableEmitter) throws Exception {
        observableEmitter.onNext(1);
        observableEmitter.onNext(2);
        observableEmitter.onNext(3);
        observableEmitter.onComplete();
    }
});

Observer&lt;Integer&gt; observer = new Observer&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Disposable d) {
                System.out.println(&quot;On Subscribe&quot;);
            }

            @Override
            public void onNext(Integer value) {
                System.out.println(&quot;On Next&quot; + value);
            }

            @Override
            public void onError(Throwable e) {
                System.out.println(&quot;On Error&quot;);
            }

            @Override
            public void onComplete() {
                System.out.println(&quot;On Complete&quot;);
            }
        };

        observable.subscribe(observer);
</code></pre>

]]></content>
  </entry>
  
</feed>
